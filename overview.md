# Continuous Integration System, Version 1

Это файл `overview.md` репозитария `https://github.com/tomsksoft-llc/cis1-docs`.

В нем содержится описание системы, состав компонент, бизнес-логика системы и каждой компоненты по отдельности, описание взаимодействия между компонентами. Версию системы можно найти в файле version.txt этого же репозитария.

Кроме требований к бизнес-логике и интерфейсу компоненты, имеются требования на состав документации и правила организации репозитариев. Их можно найти [здесь](devguide.md).

Каждая компонента должна удовлетворять требованиям, изложенным в данных документах.

# Что такое CIS, зачем она нужна

CIS - это инструмент для разработчиков программного обеспечения.

Он предназначен для автоматизации и связывания в единую цепочку рутинных операций, которые присутствуют в жизненном цикле ПО. Это операции: сборки (build), развертывания (deploy), автотестирования (autotesting), диагностика состояния систем (по запросу и периодическая), изменения состояний тикетов в система учета задач, отправки нотификаций, и т.д.

Смысл использования этого инструмента: исключить из процесса разработки ручной запуск рутинных операций, и тем самым повысить эффективность работы инженеров.

# Общее описание бизнес-логики системы

## Система реализует следующие функции:

* GUI для пользователя (web или native).
* Запуск _задач_, сохранение результатов каждого запуска (сборки) и их идентификацию, вывода на консоль каждого запуска, статуса завершения.  
Любой скрипт может иметь параметры.  
Любой скрипт может запустить еще один скрипт.  
Каждый скрипт - это исполняемый файл с точки зрения ОС.
* Скрипты разбиты на группы - _проекты_. Каждый _проект_ - это отдельный каталог, он может быть отдельным репозитарием.
* Создание/модификацию/удаление скриптов и настройку параметров _задачи_.
* Cкрипты могут запускаться не только через UI, но и из командной строки.
* Существуют версии системы для Win, Linux, Mac.
* Возможность запуска скриптов по расписанию.
* Возможность запуска скриптов по внешнему сигналу - вебхуку.
* Возможность запуска скриптов из самих скриптов (организация цепочек - сессий).
* Наличие механизма глобальных переменных сессии (эти переменные доступны всем _задачам_, выполняющимся в пределах этой сессии).
* Наличие механизма защищенного хранения доступов к внешним системам и предоставление интерфейса для использования этих доступов в скриптах.
* Визуализация процесса работы скриптов, работы цепочки скриптов.
* Удаление старых сборок.
* Самодиагностику работоспособности системы.
* Разделение прав доступа к _проектам_ через ВЕБ интерфейс.

# Список компонент

* Ядро (core).
* Библиотека вспомогательных скриптов (scripts lib)
* Интерфейс для пользователя (UI).

# Описание бизнес логики ядра

## Основные термины

<table>

<tbody>

<tr>

<td>Ядро</td>

<td>несколько скриптов, которые обеспечивают все функции системы, скрипты находятся в подкаталоге <code>core</code>.</td>

</tr>

<tr>

<td><i>Проект</i></td>

<td>Подкаталог внутри каталога <code>jobs</code>, внутри него находятся принадлежащие ему <i>задачи</i>.</td>

</tr>

<tr>

<td><i>Задача</i></td>

<td>это и каталог, который содержит все необходимое для запуска/результаты запуска, и сам процесс выполнения <i>задачи</i>.</td>

</tr>

<tr>

<td>Сборка</td>

<td>это один сеанс работы <i>задачи</i>, а также и результаты его выполнения, каждая сборка выполняется в отдельном подкаталоге внутри <i>задачи</i> (имя подкаталога сборки - это её номер).</td>

</tr>

<tr>

<td>Сессия</td>

<td><i>задачи</i> могут запускать одна другую, таким образом организовывая цепочки выполнения - это и есть сессии. Первая <i>задача</i> в цепочке начинает сессию, и она же ее закрывает. При открытии сессии ей присваивается уникальный идентификатор. Для каждой сессии создается отдельный файл лога в каталоге <code>sessions</code>, имя лог-файла совпадает с идентификатором сессии.</td>

</tr>

<tr>

<td>Библиотека вспомогательных скриптов</td>

<td>Это набор исполняемых файлов, каждый из которых выполняет какую-либо функцию, которую нужно использоваться в скриптах <i>задач</i>. Библиотечный скрипт принимает аргументы из командной строки и возвращает 0 в случае успеха, и не 0 в случае ошибки. Т.о. из скрипта <i>задачи</i> библиотечный скрипт запускается как команда операционной системы.</td>

</tr>

</tbody>

</table>


## Размещение системы на диске

```
cis_base_dir
├── core – ядро CIS (здесь находятся исполняемые файлы, которые и обеспечивают работу ядра)
│   ├── cis.conf - файл конфигурации, параметры, которые заданы в нем, нужны и ядру и другим компонентам cis для их правильной интеграции
│   └── ... - исполняемые файлы ядра
├── lib - библиотечные скрипты
├── jobs  - каталог с «задачами», они разбиты на _проекты_:
│   ├── internal – специальный _проект_, который включен прямо в CIS, в нем находятся служебные задачи, например, тест ядра
│   ├── project1
│   │   ├── job.conf - файл параметров этой «задачи»
│   │   ├── <имя фйла скрипта> - скрипт этой «задачи»
│   │   ├── job.params - файл параметров этой «задачи»
│   │   ├── 000001 - каталог, в котором лежат результаты выполнения первой сборки этой «задачи»
│   │   │   ├── <имя фйла скрипта> - файл скрипта, который запускался для выполнения этой сборки
│   │   │   │			             (в момент старата сборки он копируется из каталога выше)
│   │   │   ├── output.txt - содержимое стандартного вывода и вывода ошибок, которое было сформировано в процессе сборки
│   │   │   ├── job.params - файл параметров «задачи» с подставленными параметрами для данной сборки
│   │   │   ├── job.conf - файл конфигурации «задачи» на момент старта сборки
│   │   │   ├── exitcode.txt - в этом файле записан код возврата сркипта этой «задачи»
│   │   │   ├── exitmessage.txt - в этом файле содержится сообщение о завершении «задачи»
│   │   │   └── session_id.txt - в этом файле записан идентификатор сессии, в которой запускалася эта «задача»
│   │   ├── arbitrary_job2
│   │   └── ...
│   ├── project2 – сторонний _проекты_, здесь находятся «задачи», сделанные разработчиками _проекта_, этот _проект_ хранится в другом репозитарии (не связанном с CIS)
│   │   ├── job1
│   │   └── ...
│   └── ... – куча других _проектов_
├── logs – логфайлы работы CIS
├── sessions  - здесь находятся логи сессий (логи запусков цепочек «задач»), они нам нужны для визуализации работы системы
└── ... - прочие файлы CIS, например webui
```

## Ядро (core)

Все что необходимо для работы ядра находится в каталоге core.  
Файл `cis.conf` содержит настройки системы необходимые ей для корректной работы.

Каждая строка файла описывает один параметр.  
Формат строки: `param_name=value`.

Файл содержит информацю о конкретных именах запускаемых файлов, необходимых для работы ядра и правильной работы скриптов _задачи_, например:

```
startjob=startjob.exe
setparam=setparam.exe
getparam=getparam.exe
setvalue=setvalue.exe
getvalue=getvalue.exe
cis_cron=cis_cron.exe
```

## Задачи (jobs)

_Задачи_ находятся в подкаталоге `jobs` системы. Все _задачи_ разбиты на _проекты_, каждый из _проектов_ находится в своем подкаталоге.

Каталог _проекта_ может содержать произвольные файлы и директории которые необходимы для работы его _задач_.

Внутри каталога _задачи_ находятся:

*   файл `job.conf` - это файл конфигурации _задачи_, именно он говорит о том, что это каталог с _задачей_, **в этом файле обязательно должна быть задана как минимум переменная `script="имя файла скрипта"`, она говорит ядру какой исполняемый файл запускать для старта _задачи_**.
*   файл скрипта _задачи_ - это исполняемый файл с точки зрения системы, он будет запущен ядром cis при старте этой _задачи_.
*   файл `job.params` - описание входных параметров _задачи_.
*   подкаталоги 000001 - 999999 - здесь хранятся данные сборок (результаты выполнения).
*   Прочие произвольные файлы и каталоги необходимые для выполнения данной _задачи_.


### Формат файла job.conf

Каждая строка файла описывает один параметр.  
Формат строки: `param_name=value`.
Все параметры строковые.  
Все возможные параметры:

```
script - имя запускаемого файла скрипта этой задачи, он дожен быть исполняемым с точки зрения ОС
keep_last_success_builds - количество предыдущих успешных сборок, которое cis будет хранить на диске (если не задан, то будут храниться все)
keep_last_break_builds - количество предыдущих неуспешных сборок, которое cis будет хранить на диске (если не задан, то будут храниться все)
```


### Формат файла job.params

Каждая строка файла описывает один параметр.  
Формат строки: `param_name="value"`.  
Все параметры строковые.  
`value` задает значение параметра "по умолчанию" (правила его применения см. ниже).
Пример:

```
prm1="why?"
prm2=
prm3="third default parameter"
```

### Список служебных переменных

```
cis_base_dir - путь к корню CIS
webui_internal_address - адрес webui для взаимодействия с ядром заданый в её конфигурации
webui_internal_port - порт webui для взаимодействия с ядром заданый в её конфигурации
webui_external_address - адрес webui по которому доступно web приложение
webui_external_port - порт webui по которому достпно web приложеие
job_name - имя текущей исполняемой задачи
build_number - номер сборки исполняемой в данный момент
startjob - имя исполняемого файла startjob
setparam - имя исполняемого файла setparam
getparam - имя исполняемого файла getparan
setvalue - имя исполняемого файла setvalue
getvalue - имя исполняемого файла getvalue
maintenance - имя исполняемого файла setparam
cis_cron - имя исполняемого файла cis_cron
cis_cron_daemon - имя исполняемого файла cis_cron_daemon
session_id - идентификатор активной сессии
```

Данные переменные задаются или перед запуском родительской задачи или при выполнении того или иного действия в системе. Изменение данных переменных из произвольного скрипта может привести к непредсказуемым последствиям и не рекомендуется, хотя и может быть использовано для отладки самой CIS или в других специальных случаях.


## Запуск _задач_

Для запуска _задачи_ используем команду системы `$cis_base_dir/core/$startjob <project/job>`:

```
$cis_base_dir/core/$startjob internal/core_test
```

Если у _задачи_ есть входные параметры, то они будут запрошены с консоли в той последовательности, в которой они указаны в файле `jobs.params`.

Доступные параметры:

`--force` - добавить флаг executable скрипту перед исполнением

`--new_session` - запустить новую сессию (может быть использовано в скриптах, при необходимости)

`--params argName argValue` - запустить _задачи_ с заданными параметрами (может быть использовано вместо интерактивного считывания или вместо `setparam`)

После выполнения _задачи_ на консоль будут выданы три строки, в первой будет идентификатор сессии, во второй информация о старте задачи, ее имя, номер сборки и т.д., в третьей статус завершения:

```
$ ./startjob internal/core_test
2019-01-08-13-49-30-17549_17548
session_id=2019-01-08-13-49-30-17549_17548 action=start_job job_name=internal/core_test build_dir=000040 pid=17548 ppid=26691
Exit code: 0
```

### Запуск одной _задачи_ из другой

Для запуска дочерней _задачи_ внутри скрипта родительской _задачи_ используем команду системы `$cis_base_dir/core/$startjob <project/job>`:

```
$cis_base_dir/core/$startjob internal/core_test_sub_startjob_withargs
```

Входные параметры уже не будут запрашиваться интерактивно, они должны быть установлены в вызывающей _задаче_ перед вызовом дочерней.
Те параметры, которые не будут установлены перед стартом дочерней _задачи_, получат значения по умолчанию (из файла job.param).

Если значение по умолчанию для конкретного параметра не задано, то он останется пустым.

Для установки параметров дочерней _задачи_ выполняем внутри скрипта родительской _задачи_ команду системы `$cis_base_dir/core/$setparam <param name> <param value>`, например:

```
$cis_base_dir/core/$setparam "prm2" "this is second parameter"
$cis_base_dir/core/$setparam "prm3" "foo 3"
```

### Чтение параметров переданных _задаче_

Для чтения параметров, которые переданы _задаче_, используем внутри ее скрипта команду системы `$cis_base_dir/core/$getparam <param name>`, которая выдаст на стандартый вывод значение параметра, например:

```
prm1=$($cis_base_dir/core/$getparam prm1)
prm2=$($cis_base_dir/core/$getparam prm2)
prm3=$($cis_base_dir/core/$getparam prm3)
```

## Сессии

В момент старта первой _задачи_ в цепочке (интерактивно с консоли, или еще как-то) автоматически создается сессия, ей присваивается идентификатор. Все _подзадачи_ в этой цепочке будут иметь этот идентификатор сессии. В каталоге `sessions` системы создается лог файл для этой сессии, и `<session_id>.dat` файл для записи глобальных переменных этой сессии. Когда первая _задача_ в цепочке завершается, сессия закрывается.

Таким образом, цепочка _задач_ выполняется внутри одной сессии, что позволяет иметь им общие глобальные переменные и служебные переменные среды окружения. В лог-файл сессии будут записаны все _задачи_, которые стартуют в данной сессии и операции с глобальными переменными сессии. Так можно проследить всю цепочку запуска и завершения _задач_ и использования ими глобальных переменных сессии.

### Механизм глобальных переменных сессии

Запись переменной в сессию: `$cis_base_dir/core/$setvalue <name> <value>`, например:

```
$cis_base_dir/core/$setvalue "prm1" "$prm1"
$cis_base_dir/core/$setvalue "prm2" "$prm2"
$cis_base_dir/core/$setvalue "prm3" "$prm3"
```

Чтение переменной сессии:  `$cis_base_dir/core/$getvalue <name>`, значение переменной будет выдано на стандартный выход, пример:

```
prm1=$($cis_base_dir/core/$getvalue "prm1")
prm2=$($cis_base_dir/core/$getvalue "prm2")
prm3=$($cis_base_dir/core/$getvalue "prm3")
```

### Служебные переменные сессии, находящиеся в environment

* `job_name` - имя выполняемой в данной момент _задачи_
* `build_number` - номер ее сборки
* `session_id` - идентификатор текущей сессии
* `parent_job_name` - имя родительской _задачи_
* `parent_job_build_number` - номер сборки родительской _задачи_

### Служебные глобальные переменные сессии

* `last_job_name` - предыдущая выполненная _задача_ (например, родительская _задача_ может использовать это после завершения дочерней)
* `last_job_build_number` - номер сборки предыдущей выполненной _задачи_

## Логика работы исполнения _задачи_, её артефакты, файлы _задачи_

Каждая _задача_ находится в своем каталоге.  
В нем лежит исполняемый файл который используется для запуска _задачи_. Имя этого файла берется из файла конфигурации _задачи_: `job.conf`.  
Файл `job.params` - описание входных параметров _задачи_.  
При старте первой _задачи_ в цепочке создается новая сессия.

Если нужно запрашиваются с консоли входные параметры (если это первая _задача_ в сессии и у _задачи_ вообще есть входные параметры).

Создается каталог сборки (имя каталога = номеру сборки), в него копируются: исполняемый файл _задачи_, файл `job.params` с конкретными значениями парметров. Скрипт _задачи_ запускается в этом каталоге.

В каталог сборки записывается файл `session_id.txt` в который пришется идентификатор текущей сессии.

Весь стандартный вывод и вывод ошибок записывается в файл `output.txt`, а код завершения записывается в файл `exitcode.txt` каталога сборки.

Задача самостоятельно может записать в файл `exitmessage.txt` строку с описанием результата завершения. Это сообщение дальше может быть использовано для отображения в UI.

## Запуск _задач_ по расписанию

Для того, что бы запуск по расписанию работал `$cis_base_dir/core/$cis_cron_daemon` должен быть запущен.

Для запуска _задачи_ по расписанию используем команду системы `$cis_base_dir/core/$cis_cron --add <cron_exp> <project/job>`

Если у _задачи_ есть входные параметры, то при запуске они будут заменены параметрами по умолчанию.

Для прекращения запуска _задачи_ по расписанию используем команду системы `$cis_base_dir/core/$cis_cron --del <cron_exp> <project/job>`

Для вывода списка _задач_ запускаемых по расписанию используем команду системы `$cis_base_dir/core/$cis_cron --list [mask]`

## Запуск _задач_ по ВЕБ-хуку

Запуск _задачи_ по ВЕБ-хуку обеспечивает ВЕБ компонента системы. Здесь описаны интерфейсы, которых должны придерживаться и ВЕБ компонента и ядро CIS:

Для приема ВЕБ-хука от внешней системы используется URL:
```
http://${address}/users/${username}/webhooks/${platform}/${project}/${job}?${arg1}=${val1}&${argn}=${valn}

Где:
- ${address} - URL этой CIS
- ${username} - имя пользователя зарегистрированного в этой CIS с правами которого будет стартовать задача
- ${platform} - одно из: github, gitlab, internal
- ${project}/${job} - имя проекта/задачи для старта (также, как бы Вы их указали для startjob)
- ${arg1}=${val1}&${argn}=${valn} - параметры, которые будут переданы для старта задачи
```

Проверка подлинности пользователя производится с помощью APIAccessSecretKey, который хранится в ВЕБ компоненте CIS. Она сопоставляет пользователя из URL с его APIAccessSecretKey и в случае совпадения назначает запросу права этого пользователя (т.е. этих прав должно хватить чтобы запустить данную _задачу_).

Способ получения ключа из вебхук запроса определяется значением ${platform}. Для `gitlab` и `github` он должен быть указан для соответствующего вызова вебхука из этих систем. Для `internal`, он передается в HTTP заголовке `X-Plain-Token`.

При старте _задачи_, вызванной по ВЕБ-хуку ей передаются параметры:

* `webhook_query_string` - URL запроса
* `webhook_event_type` - тип события
* `webhook_request_body` - имя файла, который содержит тело HTTP запроса
* `${arg1}` - переменные, которые были переданы в запросе
* ...
* `${argn}`

Типы событий:

* `ping`
* `push`
* `tag_push`
* `issue`
* `note`
* `merge_request`
* `wiki_page`
* `pipeline`
* `build`
* `unknown`

В случае использования платформы `internal` событие должно быть задано явно в HTTP заголовке `X-Plain-Event`.

Сама _задача_ при выполнении должна будет удалить файл запроса (только в том случае, если она принимает соотвествующий параметр).

В случае успешного запуска _задачи_ WebUI возвращает код HTTP `200` (OK).
В случае ошибки возвращаются соотвествующие коды ошибок:

* `403` - если у пользователя нет прав для запуска данной _задачи_
* `404` - если _задача_ не существует
* `500` - в случае если не удалось запустить _задачу_

## Защищенное хранение параметров доступов к внешним системам

Приватные ключи хранятся в домашнем каталоге пользователя, под которым работает cis. Соответсвенно все, кто имеет доступ к нему имеют доступ и к ключам. UI интерфейс не предоставляет доступа к этим файлам, на них только можно ссылаться из скриптов _задач_.

Хранине логинов и паролей *TBD*...

## Самодиагностика и обслуживание системы

Базовая работоспособность ядра может быть проверена запуском _задачи_ `internal/core_test`, которая автоматически создается при развертывании стандартным скриптом. В случае удачного исполнения этой _задачи_ можно считать, что ядро корректно выполняет свои базовые функции.

Удаление старых build происходит в соответсвие с настройками каждой _задачи_.  
Это просиходит автоматически после завершения каждой _задачи_ при помощи `maintenance`.
Так же это можно сделать вручную запустив: `$cis_base_dir/core/$maintenance --job <имя задачи>`.

## Формат логов

### Основной файл лога системы

Формат записи:

```
<$(date +%Y-%m-%d:%T)> |   <pid>    |   <ppid>   | <session_id>  |    <action>     | <message>
```

Список событий, которые пишуться в него:

<table>
<tr><th>Событие</th><th>Сообщение</th></tr>
<tr><td>open_session</td><td>session_id="$session_id"</td></tr>
<tr><td>close_session</td><td>session_id="$session_id"</td></tr>
<tr><td>error_use_startjob_without_job_name</td><td></td></tr>
<tr><td>error_try_to_start_unexisted_job</td><td>job_name="$job_name"</td></tr>
<tr><td>error_cant_find_script_file</td><td>job_name="$script_file_name"</td></tr>
<tr><td>error_cant_mkdir_for_job_build</td><td>job_name="$job_name" build_dir="$build_dir"</td></tr>
<tr><td>start_projects_maintenance_loop</td><td></td></tr>
<tr><td>delete_old_build</td><td>job="$job" build_dir="$build_dir"</td></tr>
<tr><td>critical_error</td><td>desc="attempt stop session without active session" pid=$$ ppid=$PPID</td></tr>
<tr><td>critical_error</td><td>desc="attempt start nested session" session_id=$session_id</td></tr>
<tr><td>*TBD*...</td><td></td></tr>
</table>

### Файл лога сессии

Формат записи:

```
<$(date +%Y-%m-%d:%T)> |   <pid>    |   <ppid>   |    <action>     | <message>
```

Список событий, которые пишуться в него:

<table>
<tr><th>Событие</th><th>Сообщение</th></tr>
<tr><td>open_session</td><td>pid=$$ ppid=$PPID</td></tr>
<tr><td>close_session</td><td>pid=$$ ppid=$PPID</td></tr>
<tr><td>set_call_param</td><td>param_name=$param_name param_value="$param_value" pid=$$ ppid=$PPID</td></tr>
<tr><td>set_value</td><td>value_name=$value_name value="$value" pid=$$ ppid=$PPID</td></tr>
<tr><td>try_to_start_job</td><td>job_name="$job_name"</td></tr>
<tr><td>error_use_startjob_without_job_name</td><td></td></tr>
<tr><td>error_try_to_start_unexisted_job</td><td>job_name="$job_name"</td></tr>
<tr><td>error_cant_find_script_file</td><td>job_name="$job_name"</td></tr>
<tr><td>error_cant_mkdir_for_job_build</td><td>job_name="$job_name" build_dir="$build_dir"</td></tr>
<tr><td>set_call_param_to_default</td><td>param_name=$param_name param_value=$param_value</td></tr>
<tr><td>start_job</td><td>job_name=$job_name build_dir=$build_dir pid=$$ ppid=$PPID</td></tr>
<tr><td>end_job</td><td>job_name=$job_name build_dir=$build_dir exit_code=$res pid=$$ ppid=$PPID</td></tr>
<tr><td>TBD...</td><td></td></tr>
</table>

# Описание бизнес-логики UI

UI берет на себя:

* всю бизнес-логику управления правами пользователей.
* предоставляет пользователю GUI для работы с ядром CIS.
* предоставляет возможность использования webhooks.
* работает с ядром CIS в соответствие с командами от пользователя.

# Взаимодействие между Ядром и UI

UI с одной стороны запускает скрипты как регламентирует ядро CIS, читает результат их выполнения, имеет доступ к файлам скриптов и может их читать/менять. С другой стороны, он обеспечивает пользователю возможность управлять всем этим и просматривать результаты выполнения.

Взаимодействие с CIS происходит через операционную систему: запуск скрипта - это команда системы, чтение результатов - это чтение содержимого файлов, навигация по _проектам_ и _задачам_ - это навигация по файловой системе, редактирование _задачи_ - это изменение файлов _задачи_.

Для того, чтобы нотифицировать UI компоненту о событиях происходящих в CIS асинхронно у него имеется TCP-интерфейс. CIS для того, чтобы сообщить UI компоненте об этих событиях подключается по адресу заданному в переменных среды и отправляет на него события.

Ядро отправляет в webui все события в рамках каждой сессии.
