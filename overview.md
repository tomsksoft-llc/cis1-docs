# Continuous Integration System, Version 1

Это файл overview.html репозитария cis1-docs.

В нем содержится описание системы, состав компонент, бизнес-логика системы и каждой компоненты по отдельности, описание взаимодействия между компонентами. Версию системы можно найти в файле version.txt этого же репозитария.

Кроме требований к бизнес-логике и интерфейсу компоненты, имеются требования на состав документации и правила организации репозитариев. Их можно найти [здесь](devguide.md).

Каждая компонента должна удовлетворять требованиям, изложенным в данных документах.

# Что такое CIS, зачем она нужна

CIS - это инструмент для разработчиков программного обеспечения.

Он предназначен для автоматизации и связывания в единую цепочку рутинных операций, которые присутствуют в жизненном цикле ПО.

Это операции: сборки (build), развертывания (deploy), автотестирования (autotesting), диагностика состояния систем (по запросу и периодическая), и т.д.

Смысл использования этого инструмента: исключить из процесса разработки ручной запуск рутинных операций, и тем самым повысить эффективность работы инженеров.

# Общее описание бизнес-логики системы

## Система реализует следующие функции:

* GUI для пользователя (WEB или native).
* Запуск скриптов (job), сохранение результатов каждого запуска (сборки) и их идентификацию, вывода на консоль каждого запуска, статуса завершения.  
Любой скрипт может иметь параметры.  
Любой скрипт может запустить еще один скрипт.  
Каждый скрипт - это исполняемый файл с точки зрения ОС.
* Скрипты разбиты на группы - проекты. Каждый проект - это отдельный каталог, он может быть отдельным репозитарием.
* Создание/модификацию/удаление скриптов и настройку параметров job.
* Cкрипты могут запускаться не только через UI, но и из командной строки.
* Существуют версии системы для Win, Linux, Mac.
* Возможность запуска скриптов по расписанию.
* Возможность запуска скриптов по внешнему сигналу - вебхуку.
* Возможность запуска скриптов из самих скриптов (организация цепочек - сессий).
* Наличие механизма глобальных переменных сессии (эти переменные доступны всем задачам, выполняющимся в пределах этой сессии).
* Наличие механизма защищенного хранения доступов к внешним системам и предоставление интерфейса для использования этих доступов в скриптах.
* Визуализация процесса работы скриптов, работы цепочки скриптов.
* Удаление старых сборок.
* Самодиагностику работоспособности системы.
* Разделение прав доступа к проектам через ВЕБ интерфейс.
* *TBD*...

# Список компонент

* Ядро (core).
* Библиотека вспомогательных скриптов (scripts lib)
* Интерфейс для пользователя (UI).

# Описание бизнес логики ядра

## Основные термины

<table>

<tbody>

<tr>

<td><code>cis_base_dir</code></td>

<td>это системная переменная, которая должна быть установлена в environment и в ней должно быть имя каталога в котором находится система.
</td>

</tr>

<tr>

<td>Ядро</td>

<td>несколько скриптов, которые обеспечивают все функции системы, скрипты находятся в подкаталоге <code>core</code>.</td>

</tr>

<tr>

<td>Проект</td>

<td>Подкаталог внутри каталога <code>jobs</code>, внутри него находятся принадлежащие ему задачи.</td>

</tr>

<tr>

<td>Задача</td>

<td>это и каталог, который содержит все необходимое для запуска/результаты запуска, и сам процесс выполнения задачи.</td>

</tr>

<tr>

<td>Сборка</td>

<td>это один сеанс работы задачи, а также и результаты его выполнения, каждая сборка выполняется в отдельном подкаталоге внутри задачи (имя подкаталога сборки - это её номер).</td>

</tr>

<tr>

<td>Сессия</td>

<td>задачи могут запускать одна другую, таким образом организовывая цепочки выполнения - это и есть сессии. Первая задача в цепочке начинает сессию, и она же ее закрывает. При открытии сессии ей присваивается уникальный идентификатор. Для каждой сессии создается отдельный файл лога в каталоге <code>sessions</code>, имя лог-файла совпадает с идентификатором сессии.</td>

</tr>

<tr>

<td>Библиотека вспомогательных скриптов</td>

<td>Это набор исполняемых файлов, каждый из которых выполняет какую-либо функцию, которую нужно использоваться в скриптах job-ов. Библиотечный скрипт принимает аргументы из командной строки и возвращает 0 в случае успеха, и не 0 в случае ошибки. Т.о. из скрипта job-ы библиотечный скрипт запускается как команда операционной системы.</td>

</tr>

</tbody>

</table>


## Размещение системы на диске

```
\core – ядро CIS (здесь находятся исполняемые файлы, которые и обеспечивают работу ядра)
-\cis.conf - файл конфигурации, параметры, которые заданы в нем, нужны и ядру и другим компонентам cis для их правильной интеграции
\lib - библиотечные скрипты
\jobs  - каталог с «задачами», они разбиты на проекты:
-\internal – специальный проект, который включен прямо в CIS, это всякие служебные ее задачи
   -\job1
	-\job.conf - файл параметров этой job
	-\<имя фйла скрипта> - скрипт этой job
	-\job.params - файл параметров этой job
	-\000001 - каталог, в котором лежат результаты выполнения первой сборки этой job
		-\script - файл скрипта, который запускался для выполнения этой сборки
			   (в момент старата сборки он копируется из каталога выше)
		-\output.txt - содержимое стандартного вывода и вывода ошибок, которое было сформировано в процессе сборки
		-\job.params - файл параметров задачи с подставленными параметрами для данной сборки
		-\job.conf - файл конфигурации задачи на момент старта сборки
		-\exitcode.txt - в этом файле записан код возврата сркипта этой job
		-\exitmessage.txt - в этом файле содержится сообщение о завершении задачи
		-\session_id.txt - в этом файле записан идентификатор сессии, в которой запускалася эта сборка
   -\job2
   -\...
-\project1 – сторонний проект, здесь находятся зачади, сделанные разработчиками проекта, этот проект хранится в другом репозитарии (не связанном с CIS)
   -\job1
   -\job2
   -...
  -... – куча других проектов
\logs – логфайлы работы CIS
\sessions  - здесь находятся логи сессий (логи запусков цепочек jobs), они нам нужны для визуализации работы системы
```

## Ядро (core)

Все что необходимо для работы ядра находится в каталоге core.  
Файл `cis.conf` содержит сведения и настройки системы необходимые ей и внешним компонентам для правильной интеграции (например UI компоненту).

Каждая строка файла описывает один параметр.  
Формат строки: `param_name=value`.

Файл содержит информацю о конкретных именах запускаемых файлов, необходимых для работы ядра и правильной работы скриптов job, например:

```
startjob=startjob
setparam=setparam
getparam=getparam
setvalue=setvalue
getvalue=getvalue
cis_cron=cis_cron
```

## Задачи (jobs)

Задачи находятся в подкаталоге `jobs` системы. Все задачи разбиты на "проекты", каждый из проектов находится в своем подкаталоге.

Внутри каталога задачи находятся:

*   файл `job.conf` - это файл конфигурации задачи, именно он говорит о том, что это каталог с задачей, **в этом файле обязательно должна быть задана как минимум переменная `script="имя файла скрипта"`, она говорит ядру какой исполняемый файл запускать для старта задачи**
*   файл скрипта задачи - это исполняемый файл с точки зрения системы, он будет запущен ядром cis при старте этой job
*   файл `job.params` - описание входных параметров задачи
*   подкаталоги 000001 - 999999 - здесь хранятся данные сборок (результаты выполнения).


### Формат файла job.conf

Каждая строка файла описывает один параметр.  
Формат строки: `param_name=value`.
Все параметры строковые.  
Все возможные параметры:

```
script - имя запускаемого файла скрипта этой задачи, он дожен быть исполняемым с точки зрения ОС
keep_last_success_builds - количество предыдущих успешных сборок, которое cis будет хранить на диске (если не задан, то будут храниться все)
keep_last_break_builds - количество предыдущих неуспешных сборок, которое cis будет хранить на диске (если не задан, то будут храниться все)
```


### Формат файла job.params

Каждая строка файла описывает один параметр.  
Формат строки: `param_name="value"`.  
Все параметры строковые.  
`value` задает значение параметра "по умолчанию" (правила его применения см. ниже).
Пример:

```
prm1="why?"
prm2=
prm3="third default parameter"
```

## Запуск задачи

Для запуска задачи используем команду системы `$cis_base_dir/core/$startjob <project/job>`:

```
$cis_base_dir/core/$startjob internal/core_test
```

Если у задачи есть входные параметры, то они будут запрошены с консоли в той последовательности, в которой они указаны в файле `jobs.params`.
После выполнения задачи на консоль будут выданы три строки, в первой будет идентификатор сессии, во второй информация о старте задачи, ее имя, номер сборки и т.д., в третьей статус завершения:

```
$ ./startjob internal/core_test
2019-01-08-13-49-30-17549_17548
session_id=2019-01-08-13-49-30-17549_17548 action=start_job job_name=internal/core_test build_dir=000040 pid=17548 ppid=26691
Exit code: 0
```

### Чтение параметров переданных задаче

Для чтения параметров, которые переданы задаче, используем внутри ее скрипта команду системы `$cis_base_dir/core/$getparam <param name>`, которая выдаст на стандартый выход значение параметра, например:

```
prm1=$($cis_base_dir/core/$getparam prm1)
prm2=$($cis_base_dir/core/$getparam prm2)
prm3=$($cis_base_dir/core/$getparam prm3)
```


### Запуск одной задачи из другой

Для запуска дочерней задачи внутри скрипта родительской задачи используем команду системы `$cis_base_dir/core/$startjob <project/job>`:

```
$cis_base_dir/core/$startjob internal/core_test_sub_startjob_withargs
```

Входные параметры уже не будут запрашиваться интерактивно, они должны быть установлены в вызывающей задаче перед вызовом дочерней.
Те параметры, которые не будут установлены перед стартом дочерней задачи, получат значения по умолчанию.

Если значения по умолчанию не заданы, то такие параметры останутся пустыми.

Для установки параметров дочерней задачи выполняем внутри скрипта родительской задачи команду системы `$cis_base_dir/core/$setparam <param name> <param value>`, например:

```
$cis_base_dir/core/$setparam "prm2" "this is second parameter"
$cis_base_dir/core/$setparam "prm3" "foo 3"
```


## Сессии

В момент старта первой задачи в цепочке (интерактивно с консоли, или еще как-то) автоматически создается сессия, ей присваивается идентификатор. Все подзадачи в этой цепочке будут иметь этот идентификатор сессии. В каталоге `sessions` системы создается лог файл для этой сессии, и `<session_id>.dat` файл для записи глобальных переменных этой сессии. Когда "верхняя" задача в цепочке завершается, сессия закрывается.

Таким образом, цепочка задач выполняется внутри одной сессии, что позволяет иметь им общие глобальные переменные и служебные переменные среды окружения. В лог-файл сессии будут записаны все задачи, которые стартуют в данной сессии и операции с глобальными переменными сессии. Так можно проследить всю цепочку запуска и завершения задач и использования ими глобальных переменных сессии.

### Механизм глобальных переменных сессии

Запись переменной в сессию: `$cis_base_dir/core/$setvalue <name> <value>`, например:

```
$cis_base_dir/core/$setvalue "prm1" "$prm1"
$cis_base_dir/core/$setvalue "prm2" "$prm2"
$cis_base_dir/core/$setvalue "prm3" "$prm3"
```

Чтение переменной сессии:  `$cis_base_dir/core/$getvalue <name>`, значение переменной будет выдано на стандартный выход, пример:

```
prm1=$($cis_base_dir/core/$getvalue "prm1")
prm2=$($cis_base_dir/core/$getvalue "prm2")
prm3=$($cis_base_dir/core/$getvalue "prm3")
```

### Служебные переменные сессии, находящиеся в environment

* `job_name` - имя выполняемой в данной момент job
* `build_number` - номер ее сборки
* `session_id` - идентификатор текущей сессии
* `parent_job_name` - имя родительской задачи
* `parent_job_build_number` - номер сборки родительской задачи

### Служебные глобальные переменные сессии

* `last_job_name` - предыдущая выполненная job (например, родительская задача может использовать это после завершения дочерней)
* `last_job_build_number` - номер сборки предыдущей выполненной job

## Логика работы job (сборки), его артефакты, файлы job

Каждая job находится в своем каталоге.  
В нем лежит исполняемый файл который используетс для запуска job-ы. Имя этого файла берется из файла конфигурации job-ы: `job.conf`.  
Файл `job.params` - описание входных параметров job.  
При старте первой job в цепочке создается новая сессия.

Если нужно запрашиваются с консоли входные параметры (если это первая задача в сессии и у задачи вообще есть входные параметры).

Создается каталог сборки, в котором они и будет выполнятся, в него копируются: исполняемый файл job-ы, файл job.param с конкретными значениями парметров, TBD(еще чего-то?). Скрипт задачи запускается в этом каталоге.

В каталог сборки записывается файл `session_id.txt` в который пришется идентификатор текущей сессии.

Весь стандартный вывод и вывод ошибок записывается в файл `output.txt`, а код завершения записывается в файл `exitcode.txt` каталога сборки.

## Запуск job по расписанию

Для того, что бы запуск по расписанию работал `$cis_base_dir/core/$cis_cron_daemon` должен быть запущен.

Для запуска задачи по расписанию используем команду системы `$cis_base_dir/core/$cis_cron --add <cron_exp> <project/job>`

Если у задачи есть входные параметры, то при запуске они будут оставлены пустыми.

Для прекращения запуска задачи по расписанию используем команду системы `$cis_base_dir/core/$cis_cron --del <cron_exp> <project/job>`

Для вывода списка задач запускаемых по расписанию используем команду системы `$cis_base_dir/core/$cis_cron --list [mask]`

## Запуск job по ВЕБ-хуку

Запуск задачи по ВЕБ-хуку обеспечивает ВЕБ компонента системы. Здесь описаны интерфейсы, которых должны придерживаться и ВЕБ компонента и ядро CIS:

Для приема ВЕБ-хука от внешней системы используется URL:
```
http://${address}/users/${username}/webhooks/${platform}/${project}/${job}?${arg1}=${val1}&${argn}=${valn}

Где:
- ${address} - URL этой CIS
- ${username} - имя пользователя зарегистрированного в этой CIS с правами которого будет стартовать job-а
- ${platform} - одно из: github, gitlab, internal
- ${project}/${job} - имя проекта/job-ы для старта (также, как бы Вы их указали для startjob)
- ${arg1}=${val1}&${argn}=${valn} - параметры, которые будут переданы для старта job
```

Проверка подлинности пользователя производится с помощью APIAccessSecretKey, который хранится в ВЕБ компоненте CIS. Она сопоставляет пользователя из URL с его APIAccessSecretKey и в случае совпадения назначает запросу права этого пользователя (т.е. этих прав должно хватить чтобы запустить данную job).

Способ получения ключа из вебхук запроса определяется значением ${platform}. Для `gitlab` и `github` он должен быть указан для соответствующего вызова вебхука из этих систем. Для `internal`, он передается в HTTP заголовке `X-Plain-Token`.

При старте задачи, вызванной по ВЕБ-хуку ей передаются параметры:

* `webhook_query_string` - URL запроса
* `webhook_event_type` - тип события
* `webhook_request_body` - имя файла, который содержит тело HTTP запроса
* `${arg1}` - переменные, которые были переданы в запросе
* ...
* `${argn}`

Типы событий:

* `ping`
* `push`
* `tag_push`
* `issue`
* `note`
* `merge_request`
* `wiki_page`
* `pipeline`
* `build`
* `unknown`

В случае использования платформы `internal` событие должно быть задано явно в HTTP заголовке `X-Plain-Event`.

Сама задача при выполнении должна будет удалить файл запроса (только в том случае, если она принимает соотвествующий параметр).

В случае успешного запуска задачи WebUI возвращает код HTTP `200` (OK).
В случае ошибки возвращаются соотвествующие коды ошибок:

* `403` - если у пользователя нет прав для запуска данной задачи
* `404` - если задача несуществует
* `500` - в случае если не удалось запустить задачу

## Защищенное хранение параметров доступов к внешним системам

Приватные ключи хранятся в домашнем каталоге пользователя, под которым работает cis. Соответсвенно все, кто имеет доступ к нему имеют доступ и к ключам. UI интерфейс не предоставляет доступа к этим файлам, на них только можно ссылаться из скриптов job.

Хранине логинов и паролей *TBD*...

## Самодиагностика и обслуживание системы

Удаление старых build происходит в соответсвие с настройками каждой job.  
Это просиходит автоматически после завершения каждой задачи при помощи `maintenance`.
Так же это можно сделать вручную запустив: `$cis_base_dir/core/$maintenance --job <имя задачи>`.

*TBD*...

## Формат логов

### Основной файл лога системы

Формат записи:

```
<$(date +%Y-%m-%d:%T)> |   <pid>    |   <ppid>   |              <session_id>                 | <action>        | <message>
```

Список событий, которые пишуться в него:

<table>
<tr><th>Событие</th><th>Сообщение</th></tr>
<tr><td>open_session</td><td>session_id="$session_id"</td></tr>
<tr><td>close_session</td><td>session_id="$session_id"</td></tr>
<tr><td>error_use_startjob_without_job_name</td><td></td></tr>
<tr><td>error_try_to_start_unexisted_job</td><td>job_name="$job_name"</td></tr>
<tr><td>error_cant_find_script_file</td><td>job_name="$script_file_name"</td></tr>
<tr><td>error_cant_mkdir_for_job_build</td><td>job_name="$job_name" build_dir="$build_dir"</td></tr>
<tr><td>start_projects_maintenance_loop</td><td></td></tr>
<tr><td>delete_old_build</td><td>job="$job" build_dir="$build_dir"</td></tr>
<tr><td>critical_error</td><td>desc="attempt stop session without active session" pid=$$ ppid=$PPID</td></tr>
<tr><td>critical_error</td><td>desc="attempt start nested session" session_id=$session_id</td></tr>
<tr><td>*TBD*...</td><td></td></tr>
</table>

### Файл лога сессии

Формат записи:

```
<$(date +%Y-%m-%d:%T)> |   <pid>    |   <ppid>   | <action>        | <message>
```

Список событий, которые пишуться в него:

<table>
<tr><th>Событие</th><th>Сообщение</th></tr>
<tr><td>open_session</td><td>pid=$$ ppid=$PPID</td></tr>
<tr><td>close_session</td><td>pid=$$ ppid=$PPID</td></tr>
<tr><td>set_call_param</td><td>param_name=$param_name param_value="$param_value" pid=$$ ppid=$PPID</td></tr>
<tr><td>set_value</td><td>value_name=$value_name value="$value" pid=$$ ppid=$PPID</td></tr>
<tr><td>try_to_start_job</td><td>job_name="$job_name"</td></tr>
<tr><td>error_use_startjob_without_job_name</td><td></td></tr>
<tr><td>error_try_to_start_unexisted_job</td><td>job_name="$job_name"</td></tr>
<tr><td>error_cant_find_script_file</td><td>job_name="$job_name"</td></tr>
<tr><td>error_cant_mkdir_for_job_build</td><td>job_name="$job_name" build_dir="$build_dir"</td></tr>
<tr><td>set_call_param_to_default</td><td>param_name=$param_name param_value=$param_value</td></tr>
<tr><td>start_job</td><td>job_name=$job_name build_dir=$build_dir pid=$$ ppid=$PPID</td></tr>
<tr><td>end_job</td><td>job_name=$job_name build_dir=$build_dir exit_code=$res pid=$$ ppid=$PPID</td></tr>
<tr><td>TBD...</td><td></td></tr>
</table>

# Описание бизнес-логики UI

UI берет на себя:

* всю бизнес-логику управления правами пользователей
* предоставляет пользователю GUI интерфейс для работы с ядром CIS
* предоставляет возможность использования webhooks
* работает с ядром CIS в соответствие с командами от пользователя

# Взаимодействие между Ядром и UI

UI с одной стороны запускает скрипты как регламентирует ядро CIS, читает результат их выполнения, имеет доступ к файлам скриптов и может их читать/менять. С другой стороны, он обеспечивает пользователю возможность управлять всем этим и просматривать результаты выполнения.

Общение с CIS происходит через операционную систему: запуск скрипта - это команда системы, чтение результатов - это чтение содержимого файлов, навигация по проектам и job - это навигация по файловой системе, редактирование job - это изменение файлов job.

Для того, чтобы нотифицировать UI компоненту о событиях происходящих в CIS асинхронно у него имеется tcp интерфейс. CIS для того, чтобы сообщить UI компоненте об этих событиях подключается по адресу заданному в переменных среды и отправляет на него события.

Ядро отправляет в webui все события в рамках каждой сессии.